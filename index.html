<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Chia Pixelverse</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom right, #48A23F, #005C3B);
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      height: 100vh;
      overflow: hidden;
    }

    h1 {
      margin: 20px 0;
    }

    #container {
      position: relative;
      touch-action: none;
    }

    canvas {
      image-rendering: pixelated;
      display: block;
      width: 1000px;
      height: 1000px;
      background-color: transparent; /* Возвращаем прозрачный фон */
    }

    #controls {
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>Chia Pixelverse</h1>

  <div id="container">
    <canvas id="canvas" width="1000" height="1000"></canvas>
  </div>

  <div id="controls">
    <input type="color" id="colorPicker" value="#000000" />
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const container = document.getElementById('container');

    const pixelSize = 10; // Размер одного пикселя
    let drawing = false;

    // Инициализация холста
    function initCanvas() {
      const saved = localStorage.getItem('chia-pixelverse');
      if (saved) {
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = saved;
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }

    // Синхронизация с сервером
    function syncWithServer() {
      initCanvas();
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((e.clientX - rect.left) / pixelSize),
        y: Math.floor((e.clientY - rect.top) / pixelSize)
      };
    }

    function getTouchPos(e) {
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((touch.clientX - rect.left) / pixelSize),
        y: Math.floor((touch.clientY - rect.top) / pixelSize)
      };
    }

    function saveDrawing() {
      const data = canvas.toDataURL();
      localStorage.setItem('chia-pixelverse', data);
    }

    function drawPixel(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
      saveDrawing();
    }

    function draw(e) {
      let pos;
      if (e.type.includes('touch')) {
        pos = getTouchPos(e);
      } else {
        pos = getMousePos(e);
      }

      if (e.altKey || (e.touches && e.touches.length > 1)) {
        return;
      }

      drawPixel(pos.x, pos.y, colorPicker.value);
    }

    // Обработчики мыши
    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      draw(e);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (drawing) draw(e);
    });

    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseleave', () => drawing = false);

    // Обработчики касаний
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        drawing = true;
        draw(e);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (drawing && e.touches.length === 1) {
        draw(e);
      }
    });

    canvas.addEventListener('touchend', () => drawing = false);

    // Инициализация при загрузке
    window.addEventListener('load', () => {
      initCanvas();
      syncWithServer();
      setInterval(syncWithServer, 5000);
    });
  </script>
</body>
</html>
