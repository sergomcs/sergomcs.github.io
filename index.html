<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Chia Pixelverse</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom right, #48A23F, #005C3B);
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      height: 100vh;
      overflow: hidden;
    }

    h1 {
      margin: 20px 0;
      font-size: 24px;
      text-align: center;
    }

    #container-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: calc(100% - 120px);
      overflow: hidden;
    }

    #container {
      width: 1000px;
      height: 1000px;
      overflow: hidden;
      position: relative;
      border: 3px solid #ccc;
      background-image: linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc),
                        linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc);
      background-size: 20px 20px;
      background-position: 0 0, 10px 10px;
      touch-action: none;
    }

    canvas {
      image-rendering: pixelated;
      display: block;
      transform-origin: 0 0;
      position: absolute;
      left: 0;
      top: 0;
      width: 1000px;
      height: 1000px;
    }

    #controls {
      margin: 10px;
      display: flex;
      justify-content: center;
    }

    #zoom-display {
      position: fixed;
      bottom: 10px;
      right: 20px;
      background: rgba(0, 0, 0, 0.4);
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>Chia Pixelverse</h1>

  <div id="container-wrapper">
    <div id="container">
      <canvas id="canvas" width="1000" height="1000"></canvas>
    </div>
  </div>

  <div id="controls">
    <input type="color" id="colorPicker" value="#000000" />
  </div>

  <div id="zoom-display">Zoom: 100%</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const zoomDisplay = document.getElementById('zoom-display');
    const container = document.getElementById('container');
    const containerWrapper = document.getElementById('container-wrapper');

    let zoom = 1;
    let drawing = false;
    const pixelSize = 10;
    let initialDistance = null;
    let lastDataURL = '';
    let syncInterval;

    // Инициализация холста
    function initCanvas() {
      // Загружаем из localStorage
      const saved = localStorage.getItem('chia-pixelverse');
      if (saved) {
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          lastDataURL = canvas.toDataURL();
        };
        img.src = saved;
      } else {
        // Очищаем холст, если нет сохраненных данных
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lastDataURL = canvas.toDataURL();
      }
      
      // Устанавливаем начальный масштаб
      resetZoom();
    }

    // Синхронизация с хранилищем
    function syncCanvas() {
      const saved = localStorage.getItem('chia-pixelverse');
      if (saved && saved !== lastDataURL) {
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          lastDataURL = saved;
        };
        img.src = saved;
      }
    }

    // Сброс масштаба
    function resetZoom() {
      zoom = 1;
      canvas.style.transform = `scale(${zoom})`;
      zoomDisplay.textContent = `Zoom: ${Math.round(zoom * 100)}%`;
      
      // Центрируем контейнер
      centerContainer();
    }

    // Центрирование контейнера
    function centerContainer() {
      const wrapperWidth = containerWrapper.clientWidth;
      const wrapperHeight = containerWrapper.clientHeight;
      
      if (wrapperWidth > 1000) {
        container.style.margin = '0 auto';
      } else {
        container.style.margin = '0';
      }
    }

    // Зум колесиком мыши
    container.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const delta = -e.deltaY;
        const factor = delta > 0 ? 1.1 : 0.9;
        updateZoom(factor, e.clientX - container.getBoundingClientRect().left, e.clientY - container.getBoundingClientRect().top);
      }
    }, { passive: false });

    // Зум жестом на мобильном
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        initialDistance = getDistance(e.touches[0], e.touches[1]);
      }
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getDistance(e.touches[0], e.touches[1]);
        if (initialDistance !== null) {
          const factor = currentDistance / initialDistance;
          const touchCenter = getTouchCenter(e.touches[0], e.touches[1]);
          updateZoom(factor, touchCenter.x, touchCenter.y);
          initialDistance = currentDistance;
        }
      }
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) {
        initialDistance = null;
      }
    }, { passive: false });

    function getDistance(touch1, touch2) {
      return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
    }

    function getTouchCenter(touch1, touch2) {
      const rect = container.getBoundingClientRect();
      return {
        x: ((touch1.clientX + touch2.clientX) / 2) - rect.left,
        y: ((touch1.clientY + touch2.clientY) / 2) - rect.top
      };
    }

    function updateZoom(factor, centerX, centerY) {
      const oldZoom = zoom;
      zoom = Math.max(0.1, Math.min(5, zoom * factor));
      
      // Масштабирование относительно центра
      const xPercent = centerX / container.clientWidth;
      const yPercent = centerY / container.clientHeight;
      
      const deltaWidth = container.clientWidth * (zoom - oldZoom);
      const deltaHeight = container.clientHeight * (zoom - oldZoom);
      
      const offsetX = deltaWidth * xPercent;
      const offsetY = deltaHeight * yPercent;
      
      canvas.style.transform = `scale(${zoom})`;
      zoomDisplay.textContent = `Zoom: ${Math.round(zoom * 100)}%`;
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((e.clientX - rect.left) / zoom),
        y: Math.floor((e.clientY - rect.top) / zoom)
      };
    }

    function getTouchPos(e) {
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.floor((touch.clientX - rect.left) / zoom),
        y: Math.floor((touch.clientY - rect.top) / zoom)
      };
    }

    function saveDrawing() {
      const data = canvas.toDataURL();
      localStorage.setItem('chia-pixelverse', data);
      lastDataURL = data;
    }

    function drawPixel(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x - (x % pixelSize), y - (y % pixelSize), pixelSize, pixelSize);
      saveDrawing();
    }

    function draw(e) {
      let pos;
      if (e.type.includes('touch')) {
        if (e.touches.length > 1) return;
        pos = getTouchPos(e);
      } else {
        pos = getMousePos(e);
      }
      
      if (e.altKey) {
        const pixel = ctx.getImageData(pos.x, pos.y, 1, 1).data;
        const hex = `#${[pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('')}`;
        colorPicker.value = hex;
      } else {
        drawPixel(pos.x, pos.y, colorPicker.value);
      }
    }

    // Обработчики мыши
    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      draw(e);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (drawing) draw(e);
    });

    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseleave', () => drawing = false);

    // Обработчики касаний
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        drawing = true;
        draw(e);
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      if (drawing && e.touches.length === 1) {
        draw(e);
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => drawing = false);

    // Обработчик изменения размера окна
    window.addEventListener('resize', centerContainer);

    // Инициализация при загрузке
    window.addEventListener('load', () => {
      initCanvas();
      
      // Устанавливаем интервал для синхронизации (каждую секунду)
      syncInterval = setInterval(syncCanvas, 1000);
      
      // Также синхронизируем при возвращении на вкладку
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          syncCanvas();
        }
      });
    });

    // Очистка при закрытии
    window.addEventListener('beforeunload', () => {
      clearInterval(syncInterval);
    });
  </script>
</body>
</html>
